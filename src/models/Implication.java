/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package models;

/**
 * Represents an implication between two literals in the SynT theory model.
 * <p>
 * An implication connects a left-hand side literal (variable, relation, value,
 * and optional negation) to a right-hand side literal (variable, relation,
 * value, and optional negation). It is used to build the graph/matrix models
 * generated by the tool.
 * </p>
 */
public class Implication implements Element {

    /**
     * Left-hand side variable (literal 1) of the implication.
     */
    private Variable variable1;

    /**
     * Relation operator used for literal 1 (e.g., "=", ">", "<=").
     */
    private String relation1;

    /**
     * Value used for literal 1. The representation depends on the universe type
     * (e.g., enum label, boolean literal, number, or collection string).
     */
    private String value1;

    /**
     * Whether literal 1 is negated.
     */
    private boolean negated1;
    
    /**
     * Whether literal 1 is Value or Function.
     */
    private boolean valueFunction1;

    /**
     * Right-hand side variable (literal 2) of the implication.
     */
    private Variable variable2;

    /**
     * Relation operator used for literal 2 (e.g., "=", ">", "<=").
     */
    private String relation2;

    /**
     * Value used for literal 2. The representation depends on the universe type
     * (e.g., enum label, boolean literal, number, or collection string).
     */
    private String value2;

    /**
     * Whether literal 2 is negated.
     */
    private boolean negated2;
    /**
     * Whether literal 2 is Value or Function.
     */
    private boolean valueFunction2;

    /**
     * Creates a new implication between two literals.
     *
     * @param variable1 left-hand variable (literal 1)
     * @param relation1 relation operator for literal 1
     * @param value1 value for literal 1
     * @param negated1 whether literal 1 is negated
     * @param valueFunction1    whether value 1 is value (true) or function (false)
     * @param variable2 right-hand variable (literal 2)
     * @param relation2 relation operator for literal 2
     * @param value2 value for literal 2
     * @param negated2 whether literal 2 is negated
     * @param valueFunction2    whether value 2 is value (true) or function (false)
     */
    public Implication(Variable variable1, String relation1, String value1, boolean negated1, boolean valueFunction1, Variable variable2, String relation2, String value2, boolean negated2, boolean valueFunction2) {
        this.variable1 = variable1;
        this.relation1 = relation1.trim();
        this.value1 = value1.trim();
        this.negated1 = negated1;
        this.valueFunction1 = valueFunction1;
        this.variable2 = variable2;
        this.relation2 = relation2.trim();
        this.value2 = value2.trim();
        this.negated2 = negated2;
        this.valueFunction2 = valueFunction2;
    }

    /**
     * Sets the left-hand variable (literal 1).
     *
     * @param variable1 the variable to set
     */
    public void setVariable1(Variable variable1) {
        this.variable1 = variable1;
    }

    /**
     * Sets the relation operator for literal 1.
     *
     * @param relation1 the relation (e.g., "=", ">", "<")
     */
    public void setRelation1(String relation1) {
        this.relation1 = relation1.trim();
    }

    /**
     * Sets the value for literal 1.
     *
     * @param value1 the literal value
     */
    public void setValue1(String value1) {
        this.value1 = value1.trim();
    }

    /**
     * Sets whether literal 1 is negated.
     *
     * @param negated1 {@code true} if negated; otherwise {@code false}
     */
    public void setNegated1(boolean negated1) {
        this.negated1 = negated1;
    }
    
    /**
     * Sets whether value 1 is value (true) or function (false)
     *
     * @param valueFunction1 {@code true} if value; otherwise {@code false}
     */
    public void setValueFunction1(boolean valueFunction1) {
        this.valueFunction1 = valueFunction1;
    }

    /**
     * Sets the right-hand variable (literal 2).
     *
     * @param variable2 the variable to set
     */
    public void setVariable2(Variable variable2) {
        this.variable2 = variable2;
    }

    /**
     * Sets the relation operator for literal 2.
     *
     * @param relation2 the relation (e.g., "=", ">", "<")
     */
    public void setRelation2(String relation2) {
        this.relation2 = relation2.trim();
    }

    /**
     * Sets the value for literal 2.
     *
     * @param value2 the literal value
     */
    public void setValue2(String value2) {
        this.value2 = value2.trim();
    }

    /**
     * Sets whether literal 2 is negated.
     *
     * @param negated2 {@code true} if negated; otherwise {@code false}
     */
    public void setNegated2(boolean negated2) {
        this.negated2 = negated2;
    }
    
    /**
     * Sets whether value 2 is value (true) or function (false)
     *
     * @param valueFunction2 {@code true} if value; otherwise {@code false}
     */
    public void setValueFunction2(boolean valueFunction2) {
        this.valueFunction2 = valueFunction2;
    }

    /**
     * Returns the left-hand variable (literal 1).
     *
     * @return the variable for literal 1
     */
    public Variable getVariable1() {
        return variable1;
    }

    /**
     * Returns the relation operator for literal 1.
     *
     * @return the relation for literal 1
     */
    public String getRelation1() {
        return relation1;
    }

    /**
     * Returns the value for literal 1.
     *
     * @return the value for literal 1
     */
    public String getValue1() {
        return value1;
    }

    /**
     * Indicates whether literal 1 is negated.
     *
     * @return {@code true} if literal 1 is negated; otherwise {@code false}
     */
    public boolean isNegated1() {
        return negated1;
    }

    /**
     * Indicates whether value 1 is value (true) or function (false).
     *
     * @return {@code true} if valueFunction 1 is value; otherwise {@code false}
     */
    public boolean isValueFunction1() {
        return valueFunction1;
    }

    /**
     * Returns the right-hand variable (literal 2).
     *
     * @return the variable for literal 2
     */
    public Variable getVariable2() {
        return variable2;
    }

    /**
     * Returns the relation operator for literal 2.
     *
     * @return the relation for literal 2
     */
    public String getRelation2() {
        return relation2;
    }

    /**
     * Returns the value for literal 2.
     *
     * @return the value for literal 2
     */
    public String getValue2() {
        return value2;
    }

    /**
     * Indicates whether literal 2 is negated.
     *
     * @return {@code true} if literal 2 is negated; otherwise {@code false}
     */
    public boolean isNegated2() {
        return negated2;
    }

    /**
     * Indicates whether value 2 is value (true) or function (false).
     *
     * @return {@code true} if valueFunction 2 is value; otherwise {@code false}
     */
    public boolean isValueFunction2() {
        return valueFunction2;
    }
    
    /**
     * Returns a name for this element.
     * <p>
     * This type does not currently define a stable name, therefore this method
     * is not implemented.
     * </p>
     *
     * @return never returns normally
     * @throws UnsupportedOperationException always
     */
    @Override
    public String getName() {
        throw new UnsupportedOperationException("Not supported yet."); // Generated from nbfs://nbhost/SystemFileSystem/Templates/Classes/Code/GeneratedMethodBody
    }

    /**
     * Returns a human-readable representation of the implication.
     * <p>
     * Format: {@code [v1 rel1 value1] --> [v2 rel2 value2]}. Negation is shown
     * as {@code "¬ "} before each literal.
     * </p>
     *
     * @return a formatted string for this implication
     */
    @Override
    public String toString() {
        return (negated1 ? "¬ " : "") + getLiteral1() + " --> " + (negated2 ? "¬ " : "") + getLiteral2();
    }

    /**
     * Returns a contrapositive-like representation used by the UI.
     * <p>
     * It swaps the two literals and toggles negation flags to represent the
     * contrapositive view.
     * </p>
     *
     * @return the contrapositive representation string
     */
    public String toStringCR() {
        return (!negated2 ? "¬ " : "") + getLiteral2() + " --> " + (!negated1 ? "¬ " : "") + getLiteral1();
    }

    /**
     * Builds the string representation of literal 1.
     * <p>
     * Format: {@code [nickname relation value]} using the nickname of
     * {@link #variable1}.
     * </p>
     *
     * @return the formatted literal 1 string
     */
    public String getLiteral1() {
        return "[" + variable1.getNickname() + " " + relation1 + " " + value1 + "]";
    }

    /**
     * Builds the string representation of literal 2.
     * <p>
     * Format: {@code [nickname relation value]} using the nickname of
     * {@link #variable2}.
     * </p>
     *
     * @return the formatted literal 2 string
     */
    public String getLiteral2() {
        return "[" + variable2.getNickname() + " " + relation2 + " " + value2 + "]";
    }
}
